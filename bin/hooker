#!/usr/bin/env ruby
# frozen_string_literal: true

# hooker — declarative policy engine for Claude Code hooks
# https://github.com/bioneural/hooker
# MIT License — Copyright (c) 2026 Kerry Ivan Kurian
#
# Reads hook event JSON from stdin, evaluates it against policies defined
# in .claude/policies.rb, and returns a decision on stdout.
#
# Three policy types:
#
#   gate      — blocks an action. First matching gate wins.
#
#   transform — rewrites an action via a side-channel `claude -p` call.
#               The transformation happens outside the main agent's context
#               window — zero token pollution. All matching transforms are
#               accumulated into one prompt, one model call.
#
#   inject    — surfaces context before the agent acts. All matching injects
#               accumulate. Context files are read and concatenated.
#
# Execution priority: gates > transforms > injects
# Fail-open: every error path allows the action.
#
# Policy DSL (.claude/policies.rb):
#
#   policy "name" do
#     on :PreToolUse, tool: "Bash", match: :git_commit
#     gate "reason"
#   end
#
#   policy "name" do
#     on :PreToolUse, tool: "Write", match: /README\.md/, match_field: :file_path
#     transform context: ["IDENTITY.md", "STYLE.md"],
#       field: :content,
#       prompt: "Rewrite in the persona's voice."
#   end
#
#   policy "name" do
#     on :UserPromptSubmit
#     when_prompt "The prompt involves architectural decisions."
#     inject "REVIEW_PANEL.md"
#   end
#
#   policy "name" do
#     on :UserPromptSubmit
#     inject command: "bin/my-command"   # stdout becomes context
#   end
#
# DSL methods:
#
#   on(event, tool:, match:, match_field:, file:)
#     event       :PreToolUse | :UserPromptSubmit
#     tool:       regex string on tool name (PreToolUse only)
#                 known tools: Bash, Edit, MultiEdit, Write, Read,
#                 Glob, Grep, NotebookEdit, Task, WebFetch, WebSearch
#     match:      :constant | "regex" | /regex/
#                 constants: :git_commit, :git_push, :git_push_force,
#                 :git_reset, :git_rebase, :git_checkout, :git_switch,
#                 :git_merge, :git_stash, :git_restore
#     match_field: :command | :file_path | :pattern | ...
#     file:       "name" | /regex/ — sugar for match_field: :file_path
#                 strings match exact basename or path suffix
#                 regexes match against the full file_path
#
#   gate(message)                               block the action
#   transform(context:, prompt:, field:, model:) rewrite via claude -p
#   transform(command:)                          rewrite via command (JSON merge)
#   inject(*files, command:)                     surface context files or command output
#   when_prompt(condition, model:)              LLM-only plain language matching
#
# Hook wiring (.claude/settings.json):
#
#   { "hooks": { "PreToolUse": [{ "matcher": "Bash|Edit|Write",
#     "hooks": [{ "type": "command", "command": "bin/hooker" }] }] } }
#
# Dependencies: Ruby stdlib only (json, open3). No gems. No API keys.
# AI transforms use `claude -p`. Command transforms run a script.
# Classifiers use `ollama run`.

require 'json'
require 'open3'
require 'fileutils'

# -- Inline structured logging (spill protocol) --
# hooker cannot require external files — this is the minimal inline equivalent.
# Writes to a SQLite database at .state/spill/spill.db via sqlite3 CLI.
SPILL_DB = ENV['SPILL_DB'] || File.join(Dir.pwd, '.state', 'spill', 'spill.db')
@spill_db_ready = false
HOOKER_WARNINGS = []

def spill(level, msg, **ctx)
  $stderr.puts "hooker: #{msg}"
  HOOKER_WARNINGS << msg
  unless @spill_db_ready
    dir = File.dirname(SPILL_DB)
    FileUtils.mkdir_p(dir) unless File.directory?(dir)
    Open3.capture2('sqlite3', SPILL_DB, stdin_data: <<~SQL, err: File::NULL)
      PRAGMA busy_timeout = 5000;
      PRAGMA journal_mode = WAL;
      CREATE TABLE IF NOT EXISTS log (
        id INTEGER PRIMARY KEY AUTOINCREMENT, ts TEXT NOT NULL,
        tool TEXT NOT NULL, level TEXT NOT NULL, msg TEXT NOT NULL,
        pid INTEGER NOT NULL, ctx TEXT
      );
    SQL
    @spill_db_ready = true
  end
  ts = Time.now.utc.strftime('%Y-%m-%dT%H:%M:%S.%3NZ')
  escaped = msg.gsub("'", "''")
  ctx_sql = ctx.empty? ? 'NULL' : "'#{JSON.generate(ctx).gsub("'", "''")}'"
  Open3.capture2('sqlite3', SPILL_DB, stdin_data:
    "PRAGMA busy_timeout = 5000; INSERT INTO log (ts,tool,level,msg,pid,ctx) " \
    "VALUES ('#{ts}','hooker','#{level}','#{escaped}',#{Process.pid},#{ctx_sql});",
    err: File::NULL)
rescue
  nil # fail-open
end

SCREEN_HOME = ENV['SCREEN_HOME'] || File.expand_path('../../screen', File.dirname(__FILE__))
CLASSIFY_BIN = File.join(SCREEN_HOME, 'bin', 'classify')

module Hooker
  # -- DSL --

  class PolicyBuilder
    attr_reader :data

    def initialize(name)
      @data = { 'name' => name }
    end

    def on(event, tool: nil, match: nil, match_field: nil, file: nil)
      @data['event'] = event.to_s
      @data['tool'] = tool if tool
      if file
        @data['match_field'] = 'file_path'
        @data['match'] = case file
                         when Regexp then file.source
                         else "(^|/)#{Regexp.escape(file.to_s)}\\z"
                         end
      elsif match
        @data['match'] = case match
                         when Symbol then ":#{match}"
                         when Regexp then match.source
                         else match.to_s
                         end
        @data['match_field'] = match_field.to_s if match_field
      end
    end

    def gate(message = nil)
      @data['type'] = 'gate'
      @data['message'] = message if message
    end

    def transform(context: nil, prompt: nil, field: nil, model: nil, command: nil)
      @data['type'] = 'transform'
      if command
        @data['transform_command'] = command
      else
        @data['context'] = Array(context) if context
        @data['prompt'] = prompt if prompt
        @data['transform_field'] = field.to_s if field
        @data['model'] = model if model
      end
    end

    def inject(*files, command: nil)
      @data['type'] = 'inject'
      @data['context'] = files.flatten unless files.empty?
      @data['context_command'] = command if command
    end

    def when_prompt(condition, model: nil)
      @data['when'] = condition
      @data['when_model'] = model if model
    end
  end

  # Predefined match constants. Use `:name` in the match field to reference.
  # These handle tool-generated command variations (e.g. `git -C /path commit`
  # instead of `git commit`) so policy authors don't need to know the details.
  #
  # GIT_PREFIX matches `git` followed by zero or more global option tokens before
  # the subcommand. Tokens are recognized by containing characters typical of
  # flags (-), paths (/.), or config values (=). This handles:
  #   git -C /abs/path commit          (flag + absolute path)
  #   git -C relative/dir commit       (flag + relative path with /)
  #   git -c user.name=evil commit     (flag + config key=value)
  #   git --bare commit                (long flag)
  # While rejecting subcommand words in arguments:
  #   git commit -m "reset things"     (does NOT match :git_reset)
  GIT_PREFIX = 'git\b(\s+\S*[-/.=]\S*)*\s+'

  MATCH_CONSTANTS = {
    ':git_commit'     => "#{GIT_PREFIX}commit\\b",
    ':git_push'       => "#{GIT_PREFIX}push\\b",
    ':git_push_force' => "#{GIT_PREFIX}push\\b.*(--force\\b|-f\\b|\\+\\S)",
    ':git_reset'      => "#{GIT_PREFIX}reset\\b",
    ':git_rebase'     => "#{GIT_PREFIX}rebase\\b",
    ':git_checkout'   => "#{GIT_PREFIX}checkout\\b",
    ':git_switch'     => "#{GIT_PREFIX}switch\\b",
    ':git_merge'      => "#{GIT_PREFIX}merge\\b",
    ':git_stash'      => "#{GIT_PREFIX}stash\\b",
    ':git_restore'    => "#{GIT_PREFIX}restore\\b"
  }.freeze

  DEFAULT_MATCH_FIELDS = {
    'Bash'         => 'command',
    'Edit'         => 'file_path',
    'MultiEdit'    => 'file_path',
    'Write'        => 'file_path',
    'Read'         => 'file_path',
    'Glob'         => 'pattern',
    'Grep'         => 'pattern',
    'NotebookEdit' => 'notebook_path',
    'Task'         => 'prompt',
    'WebFetch'     => 'url',
    'WebSearch'    => 'query'
  }.freeze

  module_function

  # -- Parse --

  def parse_event(raw)
    JSON.parse(raw)
  rescue JSON::ParserError => e
    spill('error', "invalid JSON input: #{e.message}")
    exit 0
  end

  def find_project_roots(cwd)
    roots = []
    dir = File.expand_path(cwd)
    loop do
      roots << dir if File.exist?(File.join(dir, '.claude', 'policies.rb'))
      parent = File.dirname(dir)
      break if parent == dir
      dir = parent
    end
    roots
  end

  def load_policies(project_root)
    return [] if project_root.nil?
    path = File.join(project_root, '.claude', 'policies.rb')
    return [] unless File.exist?(path)

    policies = []
    sandbox = Object.new
    sandbox.define_singleton_method(:policy) do |name, &block|
      builder = PolicyBuilder.new(name)
      builder.instance_eval(&block)
      policies << builder.data
    end
    sandbox.instance_eval(File.read(path), path)
    policies
  rescue SyntaxError, StandardError => e
    spill('error', "failed to load policies: #{e.message}")
    []
  end

  # -- Match --

  def resolve_match_value(event, policy)
    if event['hook_event_name'] == 'UserPromptSubmit'
      return event['prompt'] || ''
    end
    tool_input = event['tool_input'] || {}
    field = policy['match_field'] || DEFAULT_MATCH_FIELDS[event['tool_name']] || 'command'
    value = tool_input[field]
    value = tool_input.to_json if value.nil?
    value.is_a?(String) ? value : value.to_s
  end

  def resolve_match_pattern(raw)
    return raw unless raw.is_a?(String) && raw.start_with?(':')
    resolved = MATCH_CONSTANTS[raw]
    if resolved.nil?
      spill('error', "unknown match constant '#{raw}'")
      return nil
    end
    resolved
  end

  def policy_matches?(policy, event)
    if policy['event']
      return false unless event['hook_event_name'] == policy['event']
    end

    if policy['tool']
      tool_re = Regexp.new("\\A(?:#{policy['tool']})\\z")
      return false unless tool_re.match?(event['tool_name'].to_s)
    end

    if policy['match']
      pattern = resolve_match_pattern(policy['match'])
      return false if pattern.nil?
      value = resolve_match_value(event, policy)
      return false unless Regexp.new(pattern).match?(value)
    end

    true
  rescue RegexpError => e
    spill('error', "invalid regex in policy '#{policy['name']}': #{e.message}")
    false
  end

  def find_matching_policies(policies, event)
    matched = policies.select { |p| policy_matches?(p, event) }
    matched = matched.select { |p| classify?(resolve_classifier(p), event) }
    {
      gates:      matched.select { |p| p['type'] == 'gate' },
      transforms: matched.select { |p| p['type'] == 'transform' },
      injects:    matched.select { |p| p['type'] == 'inject' }
    }
  end

  # -- Support --

  def read_context_files(paths, project_root)
    parts = []
    paths.each do |rel_path|
      abs_path = rel_path.start_with?('/') ? rel_path : File.join(project_root, rel_path)
      unless File.exist?(abs_path)
        spill('warn', "context file not found: #{abs_path}")
        next
      end
      filename = File.basename(rel_path)
      parts << "<#{filename}>\n#{File.read(abs_path)}\n</#{filename}>"
    end
    parts.join("\n\n")
  end

  def build_transform_prompt(transforms, event)
    context_parts = []
    seen = {}
    transforms.each do |t|
      root = t['_root']
      (t['context'] || []).each do |rel_path|
        abs = rel_path.start_with?('/') ? rel_path : File.join(root, rel_path)
        next if seen[abs]
        seen[abs] = true
        unless File.exist?(abs)
          spill('warn', "context file not found: #{abs}")
          next
        end
        filename = File.basename(rel_path)
        context_parts << "<#{filename}>\n#{File.read(abs)}\n</#{filename}>"
      end
    end
    context = context_parts.join("\n\n")

    tool_input_json = JSON.pretty_generate(event['tool_input'] || {})

    instructions = transforms.map.with_index do |t, i|
      label = transforms.length > 1 ? "#{i + 1}. " : ''
      "#{label}#{t['prompt']}"
    end.join("\n")

    parts = []
    parts << "<context>\n#{context}\n</context>" unless context.empty?
    parts << "<current_input>\n#{tool_input_json}\n</current_input>"
    parts << "<instructions>\n#{instructions}\n</instructions>"
    parts << 'Return ONLY the transformed value. No explanation, no markdown fencing.'
    parts.join("\n\n")
  end

  def call_claude(prompt, model = nil)
    cmd = ['claude', '-p']
    cmd += ['--model', model] if model
    stdout, status = Open3.capture2(*cmd, stdin_data: prompt)
    unless status.success?
      warning = "claude -p exited with #{status.exitstatus}"
      spill('warn', warning)
      return [nil, warning]
    end
    result = stdout.strip
    result = result.sub(/\A```\w*\n?/, '').sub(/\n?```\z/, '').strip
    [result, nil]
  rescue Errno::ENOENT
    spill('warn', 'claude CLI not found')
    [nil, 'claude CLI not found']
  rescue => e
    spill('error', "claude -p failed: #{e.message}")
    [nil, "claude -p failed: #{e.message}"]
  end

  def call_ollama(prompt, model = 'gemma3:1b')
    stdout, status = Open3.capture2('ollama', 'run', model, stdin_data: prompt)
    unless status.success?
      spill('error', "ollama exited with #{status.exitstatus}")
      return nil
    end
    stdout.strip
  rescue Errno::ENOENT
    spill('warn', 'ollama not found')
    nil
  rescue => e
    spill('error', "ollama failed: #{e.message}")
    nil
  end

  def resolve_classifier(policy)
    return policy['classifier'] if policy['classifier']
    return nil unless policy['when']

    {
      'condition' => policy['when'],
      'model' => policy['when_model'] || 'gemma3:1b'
    }
  end

  def classify?(classifier, event)
    return true if classifier.nil?
    condition = classifier['condition'] || classifier['prompt']
    return true unless condition

    input = {
      'condition' => condition,
      'model'     => classifier['model'] || 'gemma3:1b',
      'file_path' => event.dig('tool_input', 'file_path'),
      'command'   => event.dig('tool_input', 'command'),
      'prompt'    => event['prompt'],
      'content'   => event.dig('tool_input', 'content'),
    }.compact

    stdout, status = Open3.capture2(CLASSIFY_BIN, stdin_data: JSON.generate(input))
    unless status.success?
      spill('error', "classify exited with #{status.exitstatus}")
      return false
    end
    stdout.strip.downcase.start_with?('yes')
  rescue Errno::ENOENT
    spill('warn', "classify not found at #{CLASSIFY_BIN}")
    false
  rescue => e
    spill('error', "classification failed: #{e.message}")
    false
  end

  # -- Execute --

  def execute_gate(policy, event)
    reason = policy['message'] || "Blocked by policy: #{policy['name']}"
    output_deny(event['hook_event_name'], reason)
  end

  def execute_transforms(transforms, event)
    command_transforms = transforms.select { |t| t['transform_command'] }
    ai_transforms = transforms.reject { |t| t['transform_command'] }

    updated = (event['tool_input'] || {}).dup
    changed = false
    last_warning = nil

    # Command transforms: each runs independently, merge JSON output
    command_transforms.each do |t|
      root = t['_root']
      result = run_context_command(t['transform_command'], root, event.to_json)
      next if result.nil?
      begin
        patch = JSON.parse(result)
        updated.merge!(patch)
        changed = true
      rescue JSON::ParserError => e
        spill('error', "transform command '#{t['name']}' returned invalid JSON: #{e.message}")
      end
    end

    # AI transforms: accumulated into one claude -p call
    unless ai_transforms.empty?
      prompt = build_transform_prompt(ai_transforms, event)
      model = ai_transforms.first['model']
      response, warning = call_claude(prompt, model)
      if response && !response.empty?
        field = ai_transforms.first['transform_field'] ||
                ai_transforms.first['match_field'] ||
                DEFAULT_MATCH_FIELDS[event['tool_name']] ||
                'command'
        updated[field] = response
        changed = true
      else
        last_warning = warning
      end
    end

    [changed ? updated : nil, last_warning]
  end

  def run_context_command(command, project_root, stdin_data = nil)
    stdout, stderr, status = Open3.capture3(
      command,
      chdir: project_root,
      stdin_data: stdin_data || ''
    )
    unless status.success?
      spill('error', "context_command failed: #{stderr.strip}") unless stderr.strip.empty?
      return nil
    end
    result = stdout.strip
    result.empty? ? nil : result
  rescue Errno::ENOENT
    spill('warn', "context_command not found: #{command}")
    nil
  rescue => e
    spill('error', "context_command error: #{e.message}")
    nil
  end

  def execute_injects(injects, event)
    parts = []

    # File context — resolve each path relative to its policy's root
    seen = {}
    injects.each do |p|
      root = p['_root']
      (p['context'] || []).each do |rel_path|
        abs = rel_path.start_with?('/') ? rel_path : File.join(root, rel_path)
        next if seen[abs]
        seen[abs] = true
        unless File.exist?(abs)
          spill('warn', "context file not found: #{abs}")
          next
        end
        filename = File.basename(rel_path)
        parts << "<#{filename}>\n#{File.read(abs)}\n</#{filename}>"
      end
    end

    # Command context — send full event JSON so commands can see all fields
    stdin_data = event.to_json
    injects.each do |p|
      next unless p['context_command']
      root = p['_root']
      result = run_context_command(p['context_command'], root, stdin_data)
      parts << result if result
    end

    parts.empty? ? nil : parts.join("\n\n")
  end

  # -- Output --

  def output_deny(event_name, reason)
    puts JSON.generate({
      hookSpecificOutput: {
        hookEventName: event_name,
        permissionDecision: 'deny',
        permissionDecisionReason: reason
      }
    })
  end

  def output_updated_input(event_name, updated_input)
    puts JSON.generate({
      hookSpecificOutput: {
        hookEventName: event_name,
        updatedInput: updated_input
      }
    })
  end

  def output_additional_context(event_name, context_text)
    puts JSON.generate({
      hookSpecificOutput: {
        hookEventName: event_name,
        additionalContext: context_text
      }
    })
  end

  def output_response(event_name, response)
    hook_output = { hookEventName: event_name }
    hook_output[:updatedInput] = response[:updated_input] if response[:updated_input]

    ctx_parts = []
    ctx_parts << response[:context] if response[:context]
    ctx_parts << "hooker: #{response[:warning]}" if response[:warning]
    hook_output[:additionalContext] = ctx_parts.join("\n\n") unless ctx_parts.empty?

    puts JSON.generate({ hookSpecificOutput: hook_output })
  end

  def output_allow
    exit 0
  end

  # -- Environment --

  def load_dotenv(dir)
    env_path = File.join(dir, '.env')
    return unless File.exist?(env_path)
    File.foreach(env_path) do |line|
      line = line.strip
      next if line.empty? || line.start_with?('#')
      next unless line.include?('=')
      key, value = line.split('=', 2)
      next unless key && value && !key.empty?
      ENV[key] ||= value
    end
  rescue => e
    spill('error', "failed to load .env: #{e.message}")
  end

  # -- Entry --

  def run
    raw = $stdin.read
    exit 0 if raw.nil? || raw.strip.empty?

    event = parse_event(raw)
    cwd = event['cwd'] || Dir.pwd

    # Walk up from cwd, collect all policy roots; reverse so broadest scope first
    roots = find_project_roots(cwd)
    load_dotenv(roots.first) if roots.any?  # deepest root (closest to cwd)
    roots.reverse!  # broadest scope first for policy evaluation
    all_policies = []
    roots.each do |root|
      root_policies = load_policies(root)
      root_policies.each { |p| p['_root'] = root }
      all_policies.concat(root_policies)
    end
    if all_policies.empty?
      unless HOOKER_WARNINGS.empty?
        warning_text = "<hooker-warnings>\n#{HOOKER_WARNINGS.join("\n")}\n</hooker-warnings>"
        output_additional_context(event['hook_event_name'], warning_text)
      end
      exit 0
    end

    matched = find_matching_policies(all_policies, event)
    event_name = event['hook_event_name']

    # Gates: first match denies
    unless matched[:gates].empty?
      execute_gate(matched[:gates].first, event)
      exit 0
    end

    response = {}

    # Transforms: all matches accumulated, one claude -p call
    unless matched[:transforms].empty?
      updated, warning = execute_transforms(matched[:transforms], event)
      response[:updated_input] = updated if updated
      response[:warning] = warning if warning && !updated
    end

    # Injects: all matches accumulated
    unless matched[:injects].empty?
      context = execute_injects(matched[:injects], event)
      if context
        names = matched[:injects].map { |p| p['name'] }.join(', ')
        response[:context] = "#{context}\n\n<hooker:matched>#{names}</hooker:matched>"
      end
    end

    # Surface accumulated warnings in additionalContext
    unless HOOKER_WARNINGS.empty?
      warning_text = "<hooker-warnings>\n#{HOOKER_WARNINGS.join("\n")}\n</hooker-warnings>"
      response[:context] = response[:context] ? "#{response[:context]}\n\n#{warning_text}" : warning_text
    end

    if response.empty?
      output_allow
    else
      output_response(event_name, response)
    end
  end
end

Hooker.run
